<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Results</title>
    <!-- Library for drag-and-drop column reordering -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 2em; background-color: #f4f4f9; color: #333; }
        .container { max-width: 90%; margin: auto; background: white; padding: 2em; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1, h2 { color: #4a4a4a; }
        .actions { margin-bottom: 2em; display: flex; gap: 1em; }
        button, .button { background-color: #007bff; color: white; padding: 0.75em 1.5em; border: none; border-radius: 4px; cursor: pointer; font-size: 1em; text-decoration: none; display: inline-block; }
        .button-secondary { background-color: #6c757d; }
        button:hover, .button:hover { opacity: 0.85; }
        
        /* Table Styles */
        .table-container { margin-bottom: 2em; }
        .data-table { width: 100%; border-collapse: collapse; }
        .data-table th, .data-table td { padding: 0.75em; text-align: left; border: 1px solid #ddd; }
        .data-table th { 
            background-color: #e9ecef; 
            cursor: pointer; 
            position: relative;
            user-select: none;
        }
        /* Row coloring based on clip type */
        .data-table tr[data-type="Video"] { background-color: #28a74533; } /* Transparent green */
        .data-table tr[data-type="Audio"] { background-color: #fd7e1433; } /* Transparent orange */
        .data-table tr[data-type="Image"] { background-color: #007bff33; } /* Transparent blue */
        .data-table tr[data-type="Graphic"] { background-color: #dc354533; } /* Transparent red */
        .data-table tr[data-type="Unknown"] { background-color: #6c757d33; } /* Transparent grey */
        .data-table tr:hover[data-type] { background-color: rgba(0, 0, 0, 0.1); }

        .resizer {
            position: absolute;
            top: 0;
            right: -4px;
            width: 8px;
            height: 100%;
            cursor: col-resize;
        }
        .data-table th:hover { background-color: #d8dde2; }
        .data-table th.sort-asc::after, .data-table th.sort-desc::after {
            content: '';
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            border: 5px solid transparent;
        }
        .data-table th.sort-asc::after { border-bottom-color: #333; }
        .data-table th.sort-desc::after { border-top-color: #333; }

        /* Toggle Switch Styles */
        .table-controls { display: flex; align-items: center; gap: 1em; margin-bottom: 1em; position: relative; z-index: 2; overflow: visible; }
        .switch { position: relative; display: inline-block; width: 60px; height: 34px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 26px; width: 26px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: #007bff; }
        input:checked + .slider:before { transform: translateX(26px); }
        .filter-controls { display: flex; align-items: center; gap: 1em; }
        .filter-controls label { font-weight: normal; }
        #search-input { width: 250px; padding: 0.5em; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; }
        #type-filter { padding: 0.5em; font-size: 1em; border: 1px solid #ccc; border-radius: 4px; }
        .radio-group { display: flex; gap: 0.5em; align-items: center; border: 1px solid #ccc; padding: 0.5em; border-radius: 4px; }
        .radio-group label { margin-right: 0.5em; }
        /* Tooltip Styles */
        .tooltip { position: relative; display: inline-block; cursor: help; border-bottom: 1px dotted black; }
        .tooltip .tooltiptext { visibility: hidden; width: 220px; background-color: #555; color: #fff; text-align: center; border-radius: 6px; padding: 5px; position: absolute; z-index: 10; top: 125%; left: 50%; margin-left: -110px; opacity: 0; transition: opacity 0.3s; }
        .tooltip .tooltiptext::after { content: ""; position: absolute; bottom: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: transparent transparent #555 transparent; }
        .tooltip:hover .tooltiptext { visibility: visible; opacity: 1; }
        
        /* Timeline Visualizer Styles */
        .timeline-container { overflow-x: auto; position: relative; border: 1px solid #ccc; border-radius: 4px; padding: 10px; flex-grow: 1; }
        .timeline-wrapper { position: relative; min-width: 100%; /* Start at 100% width */ }
        .timeline-visualizer-content { position: relative; }
        .timeline-visualizer-section { position: relative; }
        .timeline-item { position: absolute; height: 20px; background-color: #007bff; border-radius: 4px; overflow: hidden; white-space: nowrap; color: white; font-size: 12px; line-height: 20px; padding-left: 5px; box-sizing: border-box; }
        .timeline-item.video { background-color: #28a745; }
        .timeline-item.audio { background-color: #fd7e14; }
        .timeline-item.graphic { background-color: #dc3545; }
        .timeline-item.image { background-color: #007bff; }
        .timeline-item.nested-sequence { background-color: #6f42c1; } /* Purple for nested sequences */
        .timeline-item.unknown { background-color: #6c757d; }
        
        /* Diagonal split-color for nested child clips */
        .timeline-item.nested-child.video { background: linear-gradient(135deg, #28a745 49.5%, #6f42c1 50.5%); }
        .timeline-item.nested-child.audio { background: linear-gradient(135deg, #fd7e14 49.5%, #6f42c1 50.5%); }
        .timeline-item.nested-child.graphic { background: linear-gradient(135deg, #dc3545 49.5%, #6f42c1 50.5%); }
        .timeline-item.nested-child.image { background: linear-gradient(135deg, #007bff 49.5%, #6f42c1 50.5%); }
        .timeline-item.nested-child.unknown { background: linear-gradient(135deg, #6c757d 49.5%, #6f42c1 50.5%); }

        .timeline-ruler { position: relative; height: 20px; margin-bottom: 10px; border-left: 2px solid #ccc; }
        .ruler-mark { position: absolute; width: 1px; height: 10px; background: #ccc; bottom: 0; }
        .ruler-label { position: absolute; bottom: 12px; transform: translateX(-50%); font-size: 10px; color: #666; }
        .timeline-separator {
            width: 100%;
            border-top: 3px solid #555; /* Thicker, darker line */
            z-index: 4; /* Below clips but above background */
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .timeline-label-gutter {
            width: 30px; /* Fixed width for the label area */
            flex-shrink: 0; /* Prevent this column from shrinking */
            position: relative; /* For positioning labels inside */
            background-color: #f4f4f9; /* Match page background to hide scrolling clips */
        }

        .timeline-section-label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: absolute;
            width: 100%;
            height: 100%;
            font-size: 14px;
            font-weight: bold;
            color: #666;
        }
        .timeline-section-label > div {
            z-index: 6;
        }

        .legend { font-size: 12px; display: flex; gap: 15px; margin-bottom: 10px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 12px; height: 12px; border-radius: 3px; }
        .legend .video { background-color: #28a745; }
        .legend .audio { background-color: #fd7e14; }
        .legend .graphic { background-color: #dc3545; }
        .legend .image { background-color: #007bff; }
        .legend .nested-sequence { background-color: #6f42c1; }
        .legend .unknown { background-color: #6c757d; }

        /* Zoom Controls */
        .zoom-controls { margin-bottom: 1em; display: flex; align-items: center; gap: 0.5em; }
        .zoom-controls button { padding: 0.25em 0.75em; font-size: 1.2em; line-height: 1; }

        /* Visualizer Controls */
        .visualizer-controls { display: flex; align-items: center; gap: 1em; margin-bottom: 1em; font-size: 14px; }
        .visualizer-controls label { display: flex; align-items: center; gap: 0.5em; cursor: pointer; }
        .visualizer-controls input { cursor: pointer; }


        /* Collapsible Section Styles */
        .collapsible-header { background-color: #6c757d; color: white; cursor: pointer; padding: 12px; width: 100%; border: none; text-align: left; outline: none; font-size: 18px; font-weight: bold; margin-top: 1em; border-radius: 4px; }
        .collapsible-header:hover { background-color: #5a6268; }
        .collapsible-header::after { content: '\25BC'; /* Down arrow */ float: right; }
        .collapsible-header.active::after { content: "\25B2"; /* Up arrow */ }
        .collapsible-content { padding: 0 18px; max-height: 0; overflow: hidden; transition: max-height 0.2s ease-out; background-color: white; }

        /* Debug Console */
        #debug-console { font-family: monospace; font-size: 12px; background-color: #2b2b2b; color: #a9b7c6; white-space: pre-wrap; padding: 10px; border-radius: 4px; }

        /* General Hide/Show */
        .hidden { display: none; }

        /* Custom Tooltip for Timeline */
        #timeline-tooltip {
            position: absolute;
            visibility: hidden;
            background-color: #333;
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            z-index: 10;
            font-size: 12px;
            line-height: 1.4;
        }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Timeline Results</h1>
        <div class="actions">
            <button id="download-csv">Download CSV</button>
            <a href="/" class="button button-secondary">Upload Another Project</a>
        </div>

        <button type="button" class="collapsible-header active">Timeline Visualizer</button>
        <div class="collapsible-content active" style="padding-top: 18px;">
            <div class="zoom-controls">
                <button id="zoom-out">-</button>
                <button id="zoom-in">+</button>
                <span>Zoom</span>
            </div>
            <div class="visualizer-controls">
                <label><input type="checkbox" id="show-nested-clips"> Show nested clips</label>
            </div>
            <div class="legend">
                <div class="legend-item"><span class="legend-color video"></span> Video</div>
                <div class="legend-item"><span class="legend-color audio"></span> Audio</div>
                <div class="legend-item"><span class="legend-color graphic"></span> Graphic</div>
                <div class="legend-item"><span class="legend-color image"></span> Image</div>
                <div class="legend-item"><span class="legend-color nested-sequence"></span> Nested Sequence</div>
                <div class="legend-item"><span class="legend-color unknown"></span> Unknown</div>
            </div>
            <div style="display: flex; align-items: stretch;">
                <div class="timeline-label-gutter" id="label-gutter">
                    <div class="timeline-section-label" id="label-container">
                        <div id="video-label" style="writing-mode: vertical-rl; transform: rotate(180deg);">Video</div>
                        <div id="label-separator-char" style="line-height: 1; margin: 4px 0;">â€”</div>
                        <div id="audio-label" style="writing-mode: vertical-rl; transform: rotate(180deg);">Audio</div>
                    </div>
                </div>
                <div class="timeline-container">
                    <div class="timeline-wrapper">
                        <div class="timeline-ruler"></div>
                        <div class="timeline-visualizer-content">
                            <div class="timeline-visualizer-section" id="video-section"></div>
                            <div class="timeline-separator"></div>
                            <div class="timeline-visualizer-section" id="audio-section"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <button type="button" class="collapsible-header active">Timeline Table</button>
        <div class="collapsible-content active" style="padding-top: 18px;">
        <div class="table-controls">
            <span>Grouped by Clip Name</span>
            <label class="switch">
                <input type="checkbox" id="view-toggle">
                <span class="slider"></span>
            </label>
            <span>One Row Per Instance</span>
            <div class="tooltip">?
                <span class="tooltiptext"><b>Grouped:</b> Each unique clip gets one row, showing all its start/end times. <br><br> <b>Per Instance:</b> Every single clip on the timeline gets its own row.</span>
            </div>
            <div class="filter-controls" style="margin-left: auto;">
                <label for="search-input">Search:</label>
                <input type="text" id="search-input" placeholder="Filter table results...">
                <label for="type-filter">Type:</label>
                <select id="type-filter">
                    <option value="">All Types</option>
                </select>
                <div class="radio-group">
                    <label><input type="radio" name="audio-filter" value="all" checked> Show All</label>
                    <label><input type="radio" name="audio-filter" value="video-only"> Video Only</label>
                    <label><input type="radio" name="audio-filter" value="audio-only"> Audio Only</label>
                </div>
            </div>
        </div>

        <div id="grouped-table" class="table-container">
            <table class="data-table">
                <thead>
                    <tr id="grouped-headers">
                        {% for header in grouped_headers %}
                            <th>{{ header }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for row in grouped_data %}
                    <tr data-type="{{ row[1] }}">{% for cell in row %}<td>{{ cell|safe }}</td>{% endfor %}</tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <div id="per-instance-table" class="table-container hidden">
            <table class="data-table">
                <thead>
                    <tr id="per-instance-headers">
                        <th>Clip Name</th>
                        <th>Clip Type</th>
                        <th>Start</th>
                        <th>End</th>
                    </tr>
                </thead>
                <tbody>
                    {% for row in per_instance_data %}
                    <tr data-type="{{ row[3] }}"><td>{{ row[0]|safe }}</td><td>{{ row[3] }}</td><td>{{ row[1] }}</td><td>{{ row[2] }}</td></tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
        </div>

        <button type="button" class="collapsible-header">Debug Console</button>
        <div class="collapsible-content">
            <div id="debug-console">{% for log in debug_logs %}{{ log }}
{% endfor %}</div>
        </div>

        <div id="timeline-tooltip"></div>
    </div>

    <script>
        const groupedCsv = {{ grouped_csv|tojson }};
        const perInstanceCsv = {{ per_instance_csv|tojson }};
        const timelineItems = {{ timeline_items|tojson }};
        console.log("Backend data received:", { groupedCsv, perInstanceCsv, timelineItems });


        // --- Timeline Data & State ---
        let zoomLevel = 1.0; // 1.0 = 100%
        const timelineDuration = {{ timeline_duration }};

        // Convert timecode (HH:MM:SS) to seconds
        function tcToSeconds(tc) {
            if (!tc) return 0;
            const parts = tc.split(':').map(Number);
            if (parts.length !== 3) return 0;
            return parts[0] * 3600 + parts[1] * 60 + parts[2];
        }

        function tc_from_seconds(s) {
            const hh = String(Math.floor(s / 3600)).padStart(2, '0');
            const mm = String(Math.floor((s % 3600) / 60)).padStart(2, '0');
            const ss = String(Math.round(s % 60)).padStart(2, '0');
            return `${hh}:${mm}:${ss}`;
        }
        // --- Synthesize Nested Sequence Blocks on the Frontend ---
        const nestedSequenceNames = new Set();
        timelineItems.forEach(item => {
            // A clip is a child of a nest if it has a source_sequence
            if (item.source_sequence && item.type !== 'Nested sequence') {
                nestedSequenceNames.add(item.source_sequence);
            }
        });

        // Now, mark which items are containers and which are children
        const synthesizedTimelineItems = timelineItems.map(item => {
            if (item.type === 'Nested sequence') {
                return { ...item, is_nested_container: true };
            }
            if (item.source_sequence) {
                return { ...item, is_nested_child: true };
            }
            return item;
        });

        nestedSequenceNames.forEach(nestName => {
            const childClips = timelineItems.filter(item => item.source_sequence === nestName);
            if (!childClips.length) return;

        });

        const viewToggle = document.getElementById('view-toggle');
        const groupedTable = document.getElementById('grouped-table');
        const perInstanceTable = document.getElementById('per-instance-table');
        const downloadButton = document.getElementById('download-csv');

        function refreshCollapsibleHeight(element) {
            const content = element.closest('.collapsible-content');
            if (content && content.classList.contains('active')) {
                content.style.maxHeight = (content.scrollHeight + 50) + "px";
            }
        }

        // --- View Toggling Logic ---
        viewToggle.addEventListener('change', () => {
            if (viewToggle.checked) {
                console.log("Switching to 'Per Instance' table view.");
                groupedTable.classList.add('hidden');
                perInstanceTable.classList.remove('hidden');
                // Recalculate height for the parent collapsible container
                refreshCollapsibleHeight(perInstanceTable);
            } else {
                groupedTable.classList.remove('hidden');
                perInstanceTable.classList.add('hidden');
            }
        });

        // --- Download CSV Logic ---
        downloadButton.addEventListener('click', () => {
            const isPerInstance = viewToggle.checked;
            console.log(`Preparing to download ${isPerInstance ? 'per-instance' : 'grouped'} CSV.`);
            const csvContent = isPerInstance ? perInstanceCsv : groupedCsv;
            const filename = isPerInstance ? 'timeline_per-instance.csv' : 'timeline_grouped.csv';

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // --- Table Sorting and Reordering Logic ---
        function makeTableInteractive(tableId) {
            const table = document.querySelector(`#${tableId} .data-table`);
            const headers = table.querySelectorAll('th');
            const tbody = table.querySelector('tbody');

            // Skip resizer for tables with no headers (or if something goes wrong)
            if (headers.length === 0) {
                return;
            }

            // Add resizers to headers
            headers.forEach(header => {
                const resizer = document.createElement('div');
                resizer.className = 'resizer';
                header.appendChild(resizer);
                makeResizable(header, resizer);
            });

            // 1. Column Sorting
            headers.forEach((header) => {
                // Don't sort if the click is on the resizer
                header.addEventListener('click', (e) => {
                    if (e.target.classList.contains('resizer')) return;
                    const index = Array.from(header.parentNode.children).indexOf(header);
                header.addEventListener('click', () => {
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const isAsc = !header.classList.contains('sort-asc');
                    
                    // Remove sorting classes from all headers
                    headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
                    header.classList.toggle('sort-asc', isAsc);
                    header.classList.toggle('sort-desc', !isAsc);

                    // Sort the rows
                    rows.sort((a, b) => {
                        const aText = a.children[index].textContent.trim();
                        const bText = b.children[index].textContent.trim();
                        
                        // Basic numeric or string comparison
                        const aVal = isNaN(aText) || aText === '' ? aText : parseFloat(aText);
                        const bVal = isNaN(bText) || bText === '' ? bText : parseFloat(bText);

                        if (aVal < bVal) return isAsc ? -1 : 1;
                        if (aVal > bVal) return isAsc ? 1 : -1;
                        return 0;
                    });

                    // Re-append sorted rows
                    rows.forEach(row => tbody.appendChild(row));
                });
                });
            });

            // 2. Column Reordering
            const headerRow = table.querySelector('thead tr');
            new Sortable(headerRow, {
                animation: 150,
                onEnd: (evt) => {
                    const oldIndex = evt.oldIndex;
                    const newIndex = evt.newIndex;
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    rows.forEach(row => {
                        const cell = row.children[oldIndex];
                        row.insertBefore(cell, row.children[newIndex + (oldIndex < newIndex ? 1 : 0)]);
                    });
                }
            });
        }

        function makeResizable(header, resizer) {
            const table = header.closest('.data-table');
            let x = 0;
            let w = 0;

            const mouseDownHandler = function (e) {
                x = e.clientX;
                w = header.offsetWidth;
                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
                table.style.tableLayout = 'fixed'; // Ensure fixed layout during resize
                e.preventDefault(); // Prevent text selection
            };

            const mouseMoveHandler = function (e) {
                const dx = e.clientX - x;
                header.style.width = `${w + dx}px`;
                header.style.minWidth = `${w + dx}px`; // Persist width
            };

            const mouseUpHandler = function () {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
            };

            resizer.addEventListener('mousedown', mouseDownHandler);
        }

        makeTableInteractive('grouped-table');
        makeTableInteractive('per-instance-table');

        // --- Advanced Table Filtering Logic ---
        const searchInput = document.getElementById('search-input');
        const typeFilter = document.getElementById('type-filter');
        const audioFilters = document.querySelectorAll('input[name="audio-filter"]');

        // Populate type filter dropdown
        const clipTypes = new Set();
        timelineItems.forEach(item => {
            if (item.type !== 'Nested sequence') {
                clipTypes.add(item.type);
            }
        });
        clipTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            typeFilter.appendChild(option);
        });

        function applyFilters() {
            const searchText = searchInput.value.toLowerCase();
            const selectedType = typeFilter.value;
            const audioFilterValue = document.querySelector('input[name="audio-filter"]:checked').value;

            const tables = [groupedTable, perInstanceTable];
            tables.forEach(table => {
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const rowText = row.textContent.toLowerCase();
                    const rowType = row.dataset.type;

                    const searchMatch = rowText.includes(searchText);
                    const typeMatch = !selectedType || rowType === selectedType;
                    
                    let audioMatch = true;
                    if (audioFilterValue === 'audio-only') {
                        audioMatch = rowType === 'Audio';
                    } else if (audioFilterValue === 'video-only') {
                        audioMatch = rowType !== 'Audio';
                    }

                    row.style.display = (searchMatch && typeMatch && audioMatch) ? '' : 'none';
                });
            });
        }

        searchInput.addEventListener('keyup', applyFilters);
        typeFilter.addEventListener('change', applyFilters);
        audioFilters.forEach(radio => radio.addEventListener('change', applyFilters));

    </script>

    <script>
        // --- Collapsible Logic ---
        document.querySelectorAll('.collapsible-header').forEach(button => {
            button.addEventListener('click', function() {
                this.classList.toggle('active');
                let content = this.nextElementSibling;
                content.classList.toggle('active');

                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = (content.scrollHeight + 50) + "px";
                }
            });
        });

        // --- Timeline Visualization Logic ---
        const timelineWrapper = document.querySelector('.timeline-wrapper');
        const ruler = document.querySelector('.timeline-ruler');
        const videoSection = document.getElementById('video-section');
        const audioSection = document.getElementById('audio-section');
        const zoomInButton = document.getElementById('zoom-in');
        const zoomOutButton = document.getElementById('zoom-out');
        const timelineContainer = document.querySelector('.timeline-container');
        const separator = document.querySelector('.timeline-separator');
        const showNestedClipsToggle = document.getElementById('show-nested-clips');

        function renderTimeline() {
            console.log(`Rendering timeline with zoomLevel: ${zoomLevel}`);
            // Clear previous render
            ruler.innerHTML = '';
            videoSection.innerHTML = '';
            audioSection.innerHTML = '';

            // Set the total width of the timeline based on zoom
            const totalWidthPercent = 100 * zoomLevel;
            timelineWrapper.style.width = `${totalWidthPercent}%`;

            // Render Ruler
            const visibleDuration = timelineDuration / zoomLevel;
            const step = Math.max(1, Math.round(visibleDuration / 8 / 5) * 5); // Aim for ~8 ruler marks
            for (let i = 0; i <= timelineDuration; i += step) {
                const percent = (i / timelineDuration) * 100;
                ruler.innerHTML += `<div class="ruler-mark" style="left: ${percent}%;"></div>`;
                ruler.innerHTML += `<div class="ruler-label" style="left: ${percent}%;">~${Math.round(i)}s</div>`;
            }

            const showNestedClips = showNestedClipsToggle.checked;

            // Filter items based on the toggle
            const itemsToRender = synthesizedTimelineItems.filter(item => {
                if (showNestedClips) {
                    // If showing nested, hide the containers
                    return !item.is_nested_container;
                } else {
                    // If not showing nested, hide the children
                    return !item.is_nested_child;
                }
            });
            

            // Render Timeline Items
            const nonAudioItems = itemsToRender.filter(item => !item.is_audio);
            const audioItems = itemsToRender.filter(item => item.is_audio);

            // Calculate the required number of tracks BEFORE positioning the items
            const maxNonAudioTrack = Math.max(...nonAudioItems.map(i => i.track), -1) + 1;

            [nonAudioItems, audioItems].forEach((items, sectionIndex) => {
                const sectionDiv = sectionIndex === 0 ? videoSection : audioSection;
                items.forEach(item => {
                const startSec = tcToSeconds(item.start_tc);
                const endSec = tcToSeconds(item.end_tc);
                const duration = endSec - startSec;

                let displayName = item.name;
                if (item.source_sequence) {
                    displayName = `${item.name} (From nested sequence: <b>${item.source_sequence}</b>)`;
                }

                const tooltipContent = `<b>Clip Name:</b> ${displayName}<br><b>Instances:</b> ${item.instance_count}<br><b>Timecode:</b> ${item.start_tc} - ${item.end_tc}<br><b>Type:</b> ${item.type}`;
                
                const itemDiv = document.createElement('div');
                
                let classList = `timeline-item ${item.type.toLowerCase().replace(' ', '-')}`;
                if (item.is_nested_child) {
                    classList += ' nested-child';
                }
                itemDiv.className = classList;

                itemDiv.style.left = `${(startSec / timelineDuration) * 100}%`;
                itemDiv.style.width = `${(duration / timelineDuration) * 100}%`;

                // Stack audio from top-down, non-audio from bottom-up
                let topPosition;
                if (item.is_audio) {
                    topPosition = item.track * 25;
                } else {
                    topPosition = (maxNonAudioTrack - 1 - item.track) * 25;
                }
                 itemDiv.style.top = `${topPosition}px`;

                itemDiv.textContent = displayName;

                // Custom Tooltip Events
                const tooltipEl = document.getElementById('timeline-tooltip');
                itemDiv.addEventListener('mousemove', (e) => {
                    tooltipEl.innerHTML = tooltipContent;
                    tooltipEl.style.visibility = 'visible';
                    // Position tooltip near cursor, but don't let it go off-screen
                    const top = e.pageY + 15;
                    const left = Math.min(e.pageX + 15, document.body.clientWidth - tooltipEl.offsetWidth - 15);
                    tooltipEl.style.top = `${top}px`;
                    tooltipEl.style.left = `${left}px`;
                });
                itemDiv.addEventListener('mouseleave', () => {
                    tooltipEl.style.visibility = 'hidden';
                });

                    sectionDiv.appendChild(itemDiv);
                });
            });

            // Set heights of sections
            const maxAudioTrack = Math.max(...audioItems.map(i => i.track), -1) + 1;
            const minAudioHeight = 50; // Minimum pixels to ensure the "Audio" label is visible

            videoSection.style.height = `${maxNonAudioTrack * 25}px`;
            audioSection.style.height = `${Math.max(minAudioHeight, maxAudioTrack * 25)}px`;
        }

        showNestedClipsToggle.addEventListener('change', () => {
            renderTimeline();
            initTimelineHeight(); // Recalculate height as content changes

            // After rendering, the visualizer's height has changed.
            // We must now update the max-height of its parent collapsible container.
            const timelineCollapsible = document.querySelector('.timeline-container').closest('.collapsible-content');
            if (timelineCollapsible && timelineCollapsible.classList.contains('active')) {
                timelineCollapsible.style.maxHeight = (timelineCollapsible.scrollHeight + 50) + "px";
            }
        });

        zoomInButton.addEventListener('click', () => {
            zoomLevel = Math.min(8.0, zoomLevel * 1.5); // Max zoom 800%
            renderTimeline();
        });

        zoomOutButton.addEventListener('click', () => {
            zoomLevel = Math.max(1.0, zoomLevel / 1.5); // Min zoom 100%
            renderTimeline();
        });

        const initTimelineHeight = () => {
            const visualizerContent = document.querySelector('.timeline-visualizer-content');
            const labelGutter = document.getElementById('label-gutter');
            const labelContainer = document.getElementById('label-container');
            const separatorChar = document.getElementById('label-separator-char');
            
            // Get absolute positions to guarantee alignment
            const separatorRect = separator.getBoundingClientRect();
            const gutterRect = labelGutter.getBoundingClientRect();

            // Calculate the desired absolute Y position for the center of the separator char
            const separatorCenterY = separatorRect.top + (separatorRect.height / 2);
            const desiredGutterY = separatorCenterY - gutterRect.top;

            labelContainer.style.top = `${desiredGutterY - separatorChar.offsetTop - (separatorChar.offsetHeight / 2)}px`;
        };

        // Initial Render on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded. Starting initial render.");

            // Set initial height for all active collapsible sections
            document.querySelectorAll('.collapsible-content.active').forEach(content => {
                content.style.maxHeight = (content.scrollHeight + 50) + "px";
            });
            
            // Hide audio label and separator if there are no audio clips
            const audioItems = synthesizedTimelineItems.filter(item => item.is_audio);
            if (audioItems.length === 0) document.getElementById('audio-label').style.display = 'none';
            if (audioItems.length === 0 || timelineItems.length === audioItems.length) separator.style.display = 'none';

            // Render the timeline to populate its content
            renderTimeline();
            // Position the labels correctly now that the content exists
            initTimelineHeight();

            // After the timeline is rendered, its container might have changed size.
            // We need to recalculate the max-height for its parent collapsible.
            const timelineCollapsible = document.querySelector('.timeline-container').closest('.collapsible-content');
            if (timelineCollapsible && timelineCollapsible.classList.contains('active')) {
                timelineCollapsible.style.maxHeight = (timelineCollapsible.scrollHeight + 50) + "px";
            }
        });
    </script>
</body>
</html>
