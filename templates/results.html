<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Results</title>
    <!-- Library for drag-and-drop column reordering -->
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <header class="results-header">
            <h2>Premiere Pro Timeline Exporter <span class="version-badge">v{{ app_version }}</span></h2>
        </header>

        <h2>Timeline Results</h2>

        <div class="actions">
            <button id="download-csv">Download CSV</button>
            <a href="/" class="button button-secondary">Upload Another Project</a>
        </div>

        <button type="button" class="collapsible-header active">Timeline Visualizer</button>
        <div class="collapsible-content active" style="padding-top: 18px;">
            <div class="zoom-controls">
                <button id="zoom-out">-</button>
                <button id="zoom-in">+</button>
                <span>Zoom</span>
            </div>
            <div class="visualizer-controls">
                <label><input type="checkbox" id="show-nested-clips"> Show nested clips</label>
            </div>
            <div class="legend">
                <div class="legend-item"><span class="legend-color video"></span> Video</div>
                <div class="legend-item"><span class="legend-color audio"></span> Audio</div>
                <div class="legend-item"><span class="legend-color graphic"></span> Graphic</div>
                <div class="legend-item"><span class="legend-color image"></span> Image</div>
                <div class="legend-item"><span class="legend-color nested-sequence"></span> Nested Sequence</div>
                <div class="legend-item"><span class="legend-color unknown"></span> Unknown</div>
            </div>
            <div style="display: flex; align-items: stretch;">
                <div class="timeline-label-gutter" id="label-gutter">
                    <div class="timeline-section-label" id="label-container">
                        <div id="video-label" style="writing-mode: vertical-rl; transform: rotate(180deg);">Video</div>
                        <div id="label-separator-char" style="line-height: 1; margin: 4px 0;">â€”</div>
                        <div id="audio-label" style="writing-mode: vertical-rl; transform: rotate(180deg);">Audio</div>
                    </div>
                </div>
                <div class="timeline-container">
                    <div class="timeline-wrapper">
                        <div class="timeline-ruler"></div>
                        <div class="timeline-visualizer-content">
                            <div class="timeline-visualizer-section" id="video-section"></div>
                            <div class="timeline-separator"></div>
                            <div class="timeline-visualizer-section" id="audio-section"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <button type="button" class="collapsible-header active">Timeline Table</button>
        <div class="collapsible-content active" style="padding-top: 18px;">
        <div class="table-controls">
            <span>Grouped by Clip Name</span>
            <label class="switch">
                <input type="checkbox" id="view-toggle">
                <span class="slider"></span>
            </label>
            <span>One Row Per Instance</span>
            <div class="tooltip">?
                <span class="tooltiptext"><b>Grouped:</b> Each unique clip gets one row, showing all its start/end times. <br><br> <b>Per Instance:</b> Every single clip on the timeline gets its own row.</span>
            </div>
            <div class="filter-controls" style="margin-left: auto;">
                <label for="search-input">Search:</label>
                <input type="text" id="search-input" placeholder="Filter table results...">
                <label for="type-filter">Type:</label>
                <select id="type-filter">
                    <option value="">All Types</option>
                </select>
                <div class="radio-group">
                    <label><input type="radio" name="audio-filter" value="all" checked> Show All</label>
                    <label><input type="radio" name="audio-filter" value="video-only"> Video Only</label>
                    <label><input type="radio" name="audio-filter" value="audio-only"> Audio Only</label>
                </div>
            </div>
        </div>

        <div id="grouped-table" class="table-container">
            <table class="data-table">
                <thead>
                    <tr id="grouped-headers">
                        {% for header in grouped_headers %}
                            <th>{{ header }}</th>
                        {% endfor %}
                    </tr>
                </thead>
                <tbody>
                    {% for row in grouped_data %}
                    <tr data-type="{{ row[1] }}">{% for cell in row %}<td>{{ cell|safe }}</td>{% endfor %}</tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>

        <div id="per-instance-table" class="table-container hidden">
            <table class="data-table">
                <thead>
                    <tr id="per-instance-headers">
                        <th>Clip Name</th>
                        <th>Clip Type</th>
                        <th>Start</th>
                        <th>End</th>
                    </tr>
                </thead>
                <tbody>
                    {% for row in per_instance_data %}
                    <tr data-type="{{ row[3] }}"><td>{{ row[0]|safe }}</td><td>{{ row[3] }}</td><td>{{ row[1] }}</td><td>{{ row[2] }}</td></tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
        </div>

        <button type="button" class="collapsible-header">Debug Console</button>
        <div class="collapsible-content">
            <div id="debug-console">{% for log in debug_logs %}{{ log }}
{% endfor %}</div>
        </div>

    </div> <!-- This was the misplaced closing div, now it correctly wraps all content -->

    <footer>
        <div class="footer-content">
            <a href="{{ repo_url }}" target="_blank" rel="noopener noreferrer">GitHub Repository</a>
            <span>Version {{ app_version }}</span>
        </div>
    </footer>

    <script>
        const groupedCsv = {{ grouped_csv|tojson }};
        const perInstanceCsv = {{ per_instance_csv|tojson }};
        const timelineItems = {{ timeline_items|tojson }};
        console.log("Backend data received:", { groupedCsv, perInstanceCsv, timelineItems });


        // --- Timeline Data & State ---
        let zoomLevel = 1.0; // 1.0 = 100%
        const timelineDuration = {{ timeline_duration }};

        // Convert timecode (HH:MM:SS) to seconds
        function tcToSeconds(tc) {
            if (!tc) return 0;
            const parts = tc.split(':').map(Number);
            if (parts.length !== 3) return 0;
            return parts[0] * 3600 + parts[1] * 60 + parts[2];
        }

        function tc_from_seconds(s) {
            const hh = String(Math.floor(s / 3600)).padStart(2, '0');
            const mm = String(Math.floor((s % 3600) / 60)).padStart(2, '0');
            const ss = String(Math.round(s % 60)).padStart(2, '0');
            return `${hh}:${mm}:${ss}`;
        }
        // --- Synthesize Nested Sequence Blocks on the Frontend ---
        const nestedSequenceNames = new Set();
        timelineItems.forEach(item => {
            // A clip is a child of a nest if it has a source_sequence
            if (item.source_sequence && item.type !== 'Nested sequence') {
                nestedSequenceNames.add(item.source_sequence);
            }
        });

        // Now, mark which items are containers and which are children
        const synthesizedTimelineItems = timelineItems.map(item => {
            if (item.type === 'Nested sequence') {
                return { ...item, is_nested_container: true };
            }
            if (item.source_sequence) {
                return { ...item, is_nested_child: true };
            }
            return item;
        });

        nestedSequenceNames.forEach(nestName => {
            const childClips = timelineItems.filter(item => item.source_sequence === nestName);
            if (!childClips.length) return;

        });

        const viewToggle = document.getElementById('view-toggle');
        const groupedTable = document.getElementById('grouped-table');
        const perInstanceTable = document.getElementById('per-instance-table');
        const downloadButton = document.getElementById('download-csv');

        function refreshCollapsibleHeight(element) {
            const content = element.closest('.collapsible-content');
            if (content && content.classList.contains('active')) {
                content.style.maxHeight = (content.scrollHeight + 50) + "px";
            }
        }

        // --- View Toggling Logic ---
        viewToggle.addEventListener('change', () => {
            if (viewToggle.checked) {
                console.log("Switching to 'Per Instance' table view.");
                groupedTable.classList.add('hidden');
                perInstanceTable.classList.remove('hidden');
                // Recalculate height for the parent collapsible container
                refreshCollapsibleHeight(perInstanceTable);
            } else {
                groupedTable.classList.remove('hidden');
                perInstanceTable.classList.add('hidden');
            }
        });

        // --- Download CSV Logic ---
        downloadButton.addEventListener('click', () => {
            const isPerInstance = viewToggle.checked;
            console.log(`Preparing to download ${isPerInstance ? 'per-instance' : 'grouped'} CSV.`);
            const csvContent = isPerInstance ? perInstanceCsv : groupedCsv;
            const filename = isPerInstance ? 'timeline_per-instance.csv' : 'timeline_grouped.csv';

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            const url = URL.createObjectURL(blob);
            link.setAttribute('href', url);
            link.setAttribute('download', filename);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        // --- Table Sorting and Reordering Logic ---
        function makeTableInteractive(tableId) {
            const table = document.querySelector(`#${tableId} .data-table`);
            const headers = table.querySelectorAll('th');
            const tbody = table.querySelector('tbody');

            // Skip resizer for tables with no headers (or if something goes wrong)
            if (headers.length === 0) {
                return;
            }

            // Add resizers to headers
            headers.forEach(header => {
                const resizer = document.createElement('div');
                resizer.className = 'resizer';
                header.appendChild(resizer);
                makeResizable(header, resizer);
            });

            // 1. Column Sorting
            headers.forEach((header) => {
                // Don't sort if the click is on the resizer
                header.addEventListener('click', (e) => {
                    if (e.target.classList.contains('resizer')) return;
                    const index = Array.from(header.parentNode.children).indexOf(header);
                header.addEventListener('click', () => {
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    const isAsc = !header.classList.contains('sort-asc');
                    
                    // Remove sorting classes from all headers
                    headers.forEach(h => h.classList.remove('sort-asc', 'sort-desc'));
                    header.classList.toggle('sort-asc', isAsc);
                    header.classList.toggle('sort-desc', !isAsc);

                    // Sort the rows
                    rows.sort((a, b) => {
                        const aText = a.children[index].textContent.trim();
                        const bText = b.children[index].textContent.trim();
                        
                        // Basic numeric or string comparison
                        const aVal = isNaN(aText) || aText === '' ? aText : parseFloat(aText);
                        const bVal = isNaN(bText) || bText === '' ? bText : parseFloat(bText);

                        if (aVal < bVal) return isAsc ? -1 : 1;
                        if (aVal > bVal) return isAsc ? 1 : -1;
                        return 0;
                    });

                    // Re-append sorted rows
                    rows.forEach(row => tbody.appendChild(row));
                });
                });
            });

            // 2. Column Reordering
            const headerRow = table.querySelector('thead tr');
            new Sortable(headerRow, {
                animation: 150,
                onEnd: (evt) => {
                    const oldIndex = evt.oldIndex;
                    const newIndex = evt.newIndex;
                    const rows = Array.from(tbody.querySelectorAll('tr'));
                    rows.forEach(row => {
                        const cell = row.children[oldIndex];
                        row.insertBefore(cell, row.children[newIndex + (oldIndex < newIndex ? 1 : 0)]);
                    });
                }
            });
        }

        function makeResizable(header, resizer) {
            const table = header.closest('.data-table');
            let x = 0;
            let w = 0;

            const mouseDownHandler = function (e) {
                x = e.clientX;
                w = header.offsetWidth;
                document.addEventListener('mousemove', mouseMoveHandler);
                document.addEventListener('mouseup', mouseUpHandler);
                table.style.tableLayout = 'fixed'; // Ensure fixed layout during resize
                e.preventDefault(); // Prevent text selection
            };

            const mouseMoveHandler = function (e) {
                const dx = e.clientX - x;
                header.style.width = `${w + dx}px`;
                header.style.minWidth = `${w + dx}px`; // Persist width
            };

            const mouseUpHandler = function () {
                document.removeEventListener('mousemove', mouseMoveHandler);
                document.removeEventListener('mouseup', mouseUpHandler);
            };

            resizer.addEventListener('mousedown', mouseDownHandler);
        }

        makeTableInteractive('grouped-table');
        makeTableInteractive('per-instance-table');

        // --- Advanced Table Filtering Logic ---
        const searchInput = document.getElementById('search-input');
        const typeFilter = document.getElementById('type-filter');
        const audioFilters = document.querySelectorAll('input[name="audio-filter"]');

        // Populate type filter dropdown
        const clipTypes = new Set();
        timelineItems.forEach(item => {
            if (item.type !== 'Nested sequence') {
                clipTypes.add(item.type);
            }
        });
        clipTypes.forEach(type => {
            const option = document.createElement('option');
            option.value = type;
            option.textContent = type;
            typeFilter.appendChild(option);
        });

        function applyFilters() {
            const searchText = searchInput.value.toLowerCase();
            const selectedType = typeFilter.value;
            const audioFilterValue = document.querySelector('input[name="audio-filter"]:checked').value;

            const tables = [groupedTable, perInstanceTable];
            tables.forEach(table => {
                const rows = table.querySelectorAll('tbody tr');
                rows.forEach(row => {
                    const rowText = row.textContent.toLowerCase();
                    const rowType = row.dataset.type;

                    const searchMatch = rowText.includes(searchText);
                    const typeMatch = !selectedType || rowType === selectedType;
                    
                    let audioMatch = true;
                    if (audioFilterValue === 'audio-only') {
                        audioMatch = rowType === 'Audio';
                    } else if (audioFilterValue === 'video-only') {
                        audioMatch = rowType !== 'Audio';
                    }

                    row.style.display = (searchMatch && typeMatch && audioMatch) ? '' : 'none';
                });
            });
        }

        searchInput.addEventListener('keyup', applyFilters);
        typeFilter.addEventListener('change', applyFilters);
        audioFilters.forEach(radio => radio.addEventListener('change', applyFilters));

    </script>

    <script>
        // --- Collapsible Logic ---
        document.querySelectorAll('.collapsible-header').forEach(button => {
            button.addEventListener('click', function() {
                this.classList.toggle('active');
                let content = this.nextElementSibling;
                content.classList.toggle('active');

                if (content.style.maxHeight) {
                    content.style.maxHeight = null;
                } else {
                    content.style.maxHeight = (content.scrollHeight + 50) + "px";
                }
            });
        });

        // --- Timeline Visualization Logic ---
        const timelineWrapper = document.querySelector('.timeline-wrapper');
        const ruler = document.querySelector('.timeline-ruler');
        const videoSection = document.getElementById('video-section');
        const audioSection = document.getElementById('audio-section');
        const zoomInButton = document.getElementById('zoom-in');
        const zoomOutButton = document.getElementById('zoom-out');
        const timelineContainer = document.querySelector('.timeline-container');
        const separator = document.querySelector('.timeline-separator');
        const showNestedClipsToggle = document.getElementById('show-nested-clips');

        function renderTimeline() {
            console.log(`Rendering timeline with zoomLevel: ${zoomLevel}`);
            // Clear previous render
            ruler.innerHTML = '';
            videoSection.innerHTML = '';
            audioSection.innerHTML = '';

            // Set the total width of the timeline based on zoom
            const totalWidthPercent = 100 * zoomLevel;
            timelineWrapper.style.width = `${totalWidthPercent}%`;

            // Render Ruler
            const visibleDuration = timelineDuration / zoomLevel;
            const step = Math.max(1, Math.round(visibleDuration / 8 / 5) * 5); // Aim for ~8 ruler marks
            for (let i = 0; i <= timelineDuration; i += step) {
                const percent = (i / timelineDuration) * 100;
                ruler.innerHTML += `<div class="ruler-mark" style="left: ${percent}%;"></div>`;
                ruler.innerHTML += `<div class="ruler-label" style="left: ${percent}%;">~${Math.round(i)}s</div>`;
            }

            const showNestedClips = showNestedClipsToggle.checked;

            // Filter items based on the toggle
            const itemsToRender = synthesizedTimelineItems.filter(item => {
                if (showNestedClips) {
                    // If showing nested, hide the containers
                    return !item.is_nested_container;
                } else {
                    // If not showing nested, hide the children
                    return !item.is_nested_child;
                }
            });
            

            // Render Timeline Items
            const nonAudioItems = itemsToRender.filter(item => !item.is_audio);
            const audioItems = itemsToRender.filter(item => item.is_audio);

            // Calculate the required number of tracks BEFORE positioning the items
            const maxNonAudioTrack = Math.max(...nonAudioItems.map(i => i.track), -1) + 1;

            [nonAudioItems, audioItems].forEach((items, sectionIndex) => {
                const sectionDiv = sectionIndex === 0 ? videoSection : audioSection;
                items.forEach(item => {
                const startSec = tcToSeconds(item.start_tc);
                const endSec = tcToSeconds(item.end_tc);
                const duration = endSec - startSec;

                let displayName = item.name;
                if (item.source_sequence) {
                    displayName = `${item.name} (From nested sequence: <b>${item.source_sequence}</b>)`;
                }

                const tooltipContent = `<b>Clip Name:</b> ${displayName}<br><b>Instances:</b> ${item.instance_count}<br><b>Timecode:</b> ${item.start_tc} - ${item.end_tc}<br><b>Type:</b> ${item.type}`;
                
                const itemDiv = document.createElement('div');
                
                let classList = `timeline-item ${item.type.toLowerCase().replace(' ', '-')}`;
                if (item.is_nested_child) {
                    classList += ' nested-child';
                }
                itemDiv.className = classList;

                itemDiv.style.left = `${(startSec / timelineDuration) * 100}%`;
                itemDiv.style.width = `${(duration / timelineDuration) * 100}%`;

                // Stack audio from top-down, non-audio from bottom-up
                let topPosition;
                if (item.is_audio) {
                    topPosition = item.track * 25;
                } else {
                    topPosition = (maxNonAudioTrack - 1 - item.track) * 25;
                }
                 itemDiv.style.top = `${topPosition}px`;

                itemDiv.textContent = displayName;

                // Custom Tooltip Events
                const tooltipEl = document.getElementById('timeline-tooltip');
                itemDiv.addEventListener('mousemove', (e) => {
                    tooltipEl.innerHTML = tooltipContent;
                    tooltipEl.style.visibility = 'visible';
                    // Position tooltip near cursor, but don't let it go off-screen
                    const top = e.pageY + 15;
                    const left = Math.min(e.pageX + 15, document.body.clientWidth - tooltipEl.offsetWidth - 15);
                    tooltipEl.style.top = `${top}px`;
                    tooltipEl.style.left = `${left}px`;
                });
                itemDiv.addEventListener('mouseleave', () => {
                    tooltipEl.style.visibility = 'hidden';
                });

                    sectionDiv.appendChild(itemDiv);
                });
            });

            // Set heights of sections
            const maxAudioTrack = Math.max(...audioItems.map(i => i.track), -1) + 1;
            const minAudioHeight = 50; // Minimum pixels to ensure the "Audio" label is visible

            videoSection.style.height = `${maxNonAudioTrack * 25}px`;
            audioSection.style.height = `${Math.max(minAudioHeight, maxAudioTrack * 25)}px`;
        }

        showNestedClipsToggle.addEventListener('change', () => {
            renderTimeline();
            initTimelineHeight(); // Recalculate height as content changes

            // After rendering, the visualizer's height has changed.
            // We must now update the max-height of its parent collapsible container.
            const timelineCollapsible = document.querySelector('.timeline-container').closest('.collapsible-content');
            if (timelineCollapsible && timelineCollapsible.classList.contains('active')) {
                timelineCollapsible.style.maxHeight = (timelineCollapsible.scrollHeight + 50) + "px";
            }
        });

        zoomInButton.addEventListener('click', () => {
            zoomLevel = Math.min(8.0, zoomLevel * 1.5); // Max zoom 800%
            renderTimeline();
        });

        zoomOutButton.addEventListener('click', () => {
            zoomLevel = Math.max(1.0, zoomLevel / 1.5); // Min zoom 100%
            renderTimeline();
        });

        const initTimelineHeight = () => {
            const visualizerContent = document.querySelector('.timeline-visualizer-content');
            const labelGutter = document.getElementById('label-gutter');
            const labelContainer = document.getElementById('label-container');
            const separatorChar = document.getElementById('label-separator-char');
            
            // Get absolute positions to guarantee alignment
            const separatorRect = separator.getBoundingClientRect();
            const gutterRect = labelGutter.getBoundingClientRect();

            // Calculate the desired absolute Y position for the center of the separator char
            const separatorCenterY = separatorRect.top + (separatorRect.height / 2);
            const desiredGutterY = separatorCenterY - gutterRect.top;

            labelContainer.style.top = `${desiredGutterY - separatorChar.offsetTop - (separatorChar.offsetHeight / 2)}px`;
        };

        // Initial Render on DOM ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded. Starting initial render.");

            // Set initial height for all active collapsible sections
            document.querySelectorAll('.collapsible-content.active').forEach(content => {
                content.style.maxHeight = (content.scrollHeight + 50) + "px";
            });
            
            // Hide audio label and separator if there are no audio clips
            const audioItems = synthesizedTimelineItems.filter(item => item.is_audio);
            if (audioItems.length === 0) document.getElementById('audio-label').style.display = 'none';
            if (audioItems.length === 0 || timelineItems.length === audioItems.length) separator.style.display = 'none';

            // Render the timeline to populate its content
            renderTimeline();
            // Position the labels correctly now that the content exists
            initTimelineHeight();

            // After the timeline is rendered, its container might have changed size.
            // We need to recalculate the max-height for its parent collapsible.
            const timelineCollapsible = document.querySelector('.timeline-container').closest('.collapsible-content');
            if (timelineCollapsible && timelineCollapsible.classList.contains('active')) {
                timelineCollapsible.style.maxHeight = (timelineCollapsible.scrollHeight + 50) + "px";
            }
        });

    </script>
</body>
</html>
